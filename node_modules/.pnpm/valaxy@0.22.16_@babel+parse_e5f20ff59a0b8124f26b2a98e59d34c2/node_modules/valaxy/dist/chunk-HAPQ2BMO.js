import {createRequire as __createRequire} from 'module';var require=__createRequire(import.meta.url);
import {
  __dirname,
  __require
} from "./chunk-UO3OS4ER.js";

// ../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// ../../node_modules/.pnpm/synckit@0.9.2/node_modules/synckit/lib/index.js
import { createHash } from "node:crypto";
import fs2 from "node:fs";
import module from "node:module";
import path2 from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import { MessageChannel, Worker, parentPort, receiveMessageOnPort, workerData } from "node:worker_threads";

// ../../node_modules/.pnpm/@pkgr+core@0.1.1/node_modules/@pkgr/core/lib/constants.js
import { createRequire } from "node:module";
var CWD = process.cwd();
var cjsRequire = typeof __require === "undefined" ? createRequire(import.meta.url) : __require;
var EXTENSIONS = [".ts", ".tsx", ...Object.keys(cjsRequire.extensions)];

// ../../node_modules/.pnpm/@pkgr+core@0.1.1/node_modules/@pkgr/core/lib/helpers.js
import fs from "node:fs";
import path from "node:path";
var tryPkg = (pkg) => {
  try {
    return cjsRequire.resolve(pkg);
  } catch (_a) {
  }
};
var isPkgAvailable = (pkg) => !!tryPkg(pkg);
var tryFile = (filePath, includeDir = false) => {
  if (typeof filePath === "string") {
    return fs.existsSync(filePath) && (includeDir || fs.statSync(filePath).isFile()) ? filePath : "";
  }
  for (const file of filePath !== null && filePath !== void 0 ? filePath : []) {
    if (tryFile(file, includeDir)) {
      return file;
    }
  }
  return "";
};
var tryExtensions = (filepath, extensions = EXTENSIONS) => {
  const ext = [...extensions, ""].find((ext2) => tryFile(filepath + ext2));
  return ext == null ? "" : filepath + ext;
};
var findUp = (searchEntry, searchFileOrIncludeDir, includeDir) => {
  console.assert(path.isAbsolute(searchEntry));
  if (!tryFile(searchEntry, true) || searchEntry !== CWD && !searchEntry.startsWith(CWD + path.sep)) {
    return "";
  }
  searchEntry = path.resolve(fs.statSync(searchEntry).isDirectory() ? searchEntry : path.resolve(searchEntry, ".."));
  const isSearchFile = typeof searchFileOrIncludeDir === "string";
  const searchFile = isSearchFile ? searchFileOrIncludeDir : "package.json";
  do {
    const searched = tryFile(path.resolve(searchEntry, searchFile), isSearchFile && includeDir);
    if (searched) {
      return searched;
    }
    searchEntry = path.resolve(searchEntry, "..");
  } while (searchEntry === CWD || searchEntry.startsWith(CWD + path.sep));
  return "";
};

// ../../node_modules/.pnpm/synckit@0.9.2/node_modules/synckit/lib/index.js
var INT32_BYTES = 4;
var TsRunner = {
  TsNode: "ts-node",
  EsbuildRegister: "esbuild-register",
  EsbuildRunner: "esbuild-runner",
  SWC: "swc",
  TSX: "tsx"
};
var { NODE_OPTIONS, SYNCKIT_EXEC_ARGV, SYNCKIT_GLOBAL_SHIMS, SYNCKIT_TIMEOUT, SYNCKIT_TS_RUNNER } = process.env;
var IS_NODE_20 = Number(process.versions.node.split(".")[0]) >= 20;
var DEFAULT_TIMEOUT = SYNCKIT_TIMEOUT ? +SYNCKIT_TIMEOUT : void 0;
var DEFAULT_EXEC_ARGV = (SYNCKIT_EXEC_ARGV === null || SYNCKIT_EXEC_ARGV === void 0 ? void 0 : SYNCKIT_EXEC_ARGV.split(",")) || [];
var DEFAULT_TS_RUNNER = SYNCKIT_TS_RUNNER;
var DEFAULT_GLOBAL_SHIMS = ["1", "true"].includes(SYNCKIT_GLOBAL_SHIMS);
var DEFAULT_GLOBAL_SHIMS_PRESET = [
  {
    moduleName: "node-fetch",
    globalName: "fetch"
  },
  {
    moduleName: "node:perf_hooks",
    globalName: "performance",
    named: "performance"
  }
];
var MTS_SUPPORTED_NODE_VERSION = 16;
var syncFnCache;
function extractProperties(object) {
  if (object && typeof object === "object") {
    const properties = {};
    for (const key in object) {
      properties[key] = object[key];
    }
    return properties;
  }
}
function createSyncFn(workerPath, timeoutOrOptions) {
  syncFnCache !== null && syncFnCache !== void 0 ? syncFnCache : syncFnCache = /* @__PURE__ */ new Map();
  const cachedSyncFn = syncFnCache.get(workerPath);
  if (cachedSyncFn) {
    return cachedSyncFn;
  }
  if (!path2.isAbsolute(workerPath)) {
    throw new Error("`workerPath` must be absolute");
  }
  const syncFn = startWorkerThread(workerPath, typeof timeoutOrOptions === "number" ? { timeout: timeoutOrOptions } : timeoutOrOptions);
  syncFnCache.set(workerPath, syncFn);
  return syncFn;
}
var cjsRequire2 = typeof __require === "undefined" ? module.createRequire(import.meta.url) : __require;
var dataUrl = (code) => new URL(`data:text/javascript,${encodeURIComponent(code)}`);
var isFile = (path3) => {
  var _a;
  try {
    return !!((_a = fs2.statSync(path3, { throwIfNoEntry: false })) === null || _a === void 0 ? void 0 : _a.isFile());
  } catch (_b) {
    return false;
  }
};
var setupTsRunner = (workerPath, { execArgv, tsRunner }) => {
  let ext = path2.extname(workerPath);
  if (!/[/\\]node_modules[/\\]/.test(workerPath) && (!ext || /^\.[cm]?js$/.test(ext))) {
    const workPathWithoutExt = ext ? workerPath.slice(0, -ext.length) : workerPath;
    let extensions;
    switch (ext) {
      case ".cjs": {
        extensions = [".cts", ".cjs"];
        break;
      }
      case ".mjs": {
        extensions = [".mts", ".mjs"];
        break;
      }
      default: {
        extensions = [".ts", ".js"];
        break;
      }
    }
    const found = tryExtensions(workPathWithoutExt, extensions);
    let differentExt;
    if (found && (!ext || (differentExt = found !== workPathWithoutExt))) {
      workerPath = found;
      if (differentExt) {
        ext = path2.extname(workerPath);
      }
    }
  }
  const isTs = /\.[cm]?ts$/.test(workerPath);
  let jsUseEsm = workerPath.endsWith(".mjs");
  let tsUseEsm = workerPath.endsWith(".mts");
  if (isTs) {
    if (!tsUseEsm) {
      const pkg = findUp(workerPath);
      if (pkg) {
        tsUseEsm = cjsRequire2(pkg).type === "module";
      }
    }
    if (tsRunner == null && isPkgAvailable(TsRunner.TsNode)) {
      tsRunner = TsRunner.TsNode;
    }
    switch (tsRunner) {
      case TsRunner.TsNode: {
        if (tsUseEsm) {
          if (!execArgv.includes("--loader")) {
            execArgv = ["--loader", `${TsRunner.TsNode}/esm`, ...execArgv];
          }
        } else if (!execArgv.includes("-r")) {
          execArgv = ["-r", `${TsRunner.TsNode}/register`, ...execArgv];
        }
        break;
      }
      case TsRunner.EsbuildRegister: {
        if (!execArgv.includes("-r")) {
          execArgv = ["-r", TsRunner.EsbuildRegister, ...execArgv];
        }
        break;
      }
      case TsRunner.EsbuildRunner: {
        if (!execArgv.includes("-r")) {
          execArgv = ["-r", `${TsRunner.EsbuildRunner}/register`, ...execArgv];
        }
        break;
      }
      case TsRunner.SWC: {
        if (!execArgv.includes("-r")) {
          execArgv = ["-r", `@${TsRunner.SWC}-node/register`, ...execArgv];
        }
        break;
      }
      case TsRunner.TSX: {
        if (!execArgv.includes("--loader")) {
          execArgv = ["--loader", TsRunner.TSX, ...execArgv];
        }
        break;
      }
      default: {
        throw new Error(`Unknown ts runner: ${String(tsRunner)}`);
      }
    }
  } else if (!jsUseEsm) {
    const pkg = findUp(workerPath);
    if (pkg) {
      jsUseEsm = cjsRequire2(pkg).type === "module";
    }
  }
  let resolvedPnpLoaderPath;
  if (process.versions.pnp) {
    const nodeOptions = NODE_OPTIONS === null || NODE_OPTIONS === void 0 ? void 0 : NODE_OPTIONS.split(/\s+/);
    let pnpApiPath;
    try {
      pnpApiPath = cjsRequire2.resolve("pnpapi");
    } catch (_a) {
    }
    if (pnpApiPath && !(nodeOptions === null || nodeOptions === void 0 ? void 0 : nodeOptions.some((option, index) => ["-r", "--require"].includes(option) && pnpApiPath === cjsRequire2.resolve(nodeOptions[index + 1]))) && !execArgv.includes(pnpApiPath)) {
      execArgv = ["-r", pnpApiPath, ...execArgv];
      const pnpLoaderPath = path2.resolve(pnpApiPath, "../.pnp.loader.mjs");
      if (isFile(pnpLoaderPath)) {
        resolvedPnpLoaderPath = pathToFileURL(pnpLoaderPath).toString();
        if (!IS_NODE_20) {
          execArgv = [
            "--experimental-loader",
            resolvedPnpLoaderPath,
            ...execArgv
          ];
        }
      }
    }
  }
  return {
    ext,
    isTs,
    jsUseEsm,
    tsRunner,
    tsUseEsm,
    workerPath,
    pnpLoaderPath: resolvedPnpLoaderPath,
    execArgv
  };
};
var md5Hash = (text) => createHash("md5").update(text).digest("hex");
var encodeImportModule = (moduleNameOrGlobalShim, type = "import") => {
  const { moduleName, globalName, named, conditional } = typeof moduleNameOrGlobalShim === "string" ? { moduleName: moduleNameOrGlobalShim } : moduleNameOrGlobalShim;
  const importStatement = type === "import" ? `import${globalName ? " " + (named === null ? "* as " + globalName : (named === null || named === void 0 ? void 0 : named.trim()) ? `{${named}}` : globalName) + " from" : ""} '${path2.isAbsolute(moduleName) ? String(pathToFileURL(moduleName)) : moduleName}'` : `${globalName ? "const " + ((named === null || named === void 0 ? void 0 : named.trim()) ? `{${named}}` : globalName) + "=" : ""}require('${moduleName.replace(/\\/g, "\\\\")}')`;
  if (!globalName) {
    return importStatement;
  }
  const overrideStatement = `globalThis.${globalName}=${(named === null || named === void 0 ? void 0 : named.trim()) ? named : globalName}`;
  return importStatement + (conditional === false ? `;${overrideStatement}` : `;if(!globalThis.${globalName})${overrideStatement}`);
};
var _generateGlobals = (globalShims, type) => globalShims.reduce((acc, shim) => `${acc}${acc ? ";" : ""}${encodeImportModule(shim, type)}`, "");
var globalsCache;
var tmpdir;
var _dirname = typeof __dirname === "undefined" ? path2.dirname(fileURLToPath(import.meta.url)) : __dirname;
var sharedBuffer;
var sharedBufferView;
var generateGlobals = (workerPath, globalShims, type = "import") => {
  globalsCache !== null && globalsCache !== void 0 ? globalsCache : globalsCache = /* @__PURE__ */ new Map();
  const cached = globalsCache.get(workerPath);
  if (cached) {
    const [content2, filepath2] = cached;
    if (type === "require" && !filepath2 || type === "import" && filepath2 && isFile(filepath2)) {
      return content2;
    }
  }
  const globals = _generateGlobals(globalShims, type);
  let content = globals;
  let filepath;
  if (type === "import") {
    if (!tmpdir) {
      tmpdir = path2.resolve(findUp(_dirname), "../node_modules/.synckit");
    }
    fs2.mkdirSync(tmpdir, { recursive: true });
    filepath = path2.resolve(tmpdir, md5Hash(workerPath) + ".mjs");
    content = encodeImportModule(filepath);
    fs2.writeFileSync(filepath, globals);
  }
  globalsCache.set(workerPath, [content, filepath]);
  return content;
};
function startWorkerThread(workerPath, { timeout = DEFAULT_TIMEOUT, execArgv = DEFAULT_EXEC_ARGV, tsRunner = DEFAULT_TS_RUNNER, transferList = [], globalShims = DEFAULT_GLOBAL_SHIMS } = {}) {
  const { port1: mainPort, port2: workerPort } = new MessageChannel();
  const { isTs, ext, jsUseEsm, tsUseEsm, tsRunner: finalTsRunner, workerPath: finalWorkerPath, pnpLoaderPath, execArgv: finalExecArgv } = setupTsRunner(workerPath, { execArgv, tsRunner });
  const workerPathUrl = pathToFileURL(finalWorkerPath);
  if (/\.[cm]ts$/.test(finalWorkerPath)) {
    const isTsxSupported = !tsUseEsm || Number.parseFloat(process.versions.node) >= MTS_SUPPORTED_NODE_VERSION;
    if (!finalTsRunner) {
      throw new Error("No ts runner specified, ts worker path is not supported");
    } else if ([
      TsRunner.EsbuildRegister,
      TsRunner.EsbuildRunner,
      TsRunner.SWC,
      ...isTsxSupported ? [] : [TsRunner.TSX]
    ].includes(finalTsRunner)) {
      throw new Error(`${finalTsRunner} is not supported for ${ext} files yet` + (isTsxSupported ? ", you can try [tsx](https://github.com/esbuild-kit/tsx) instead" : ""));
    }
  }
  const finalGlobalShims = (globalShims === true ? DEFAULT_GLOBAL_SHIMS_PRESET : Array.isArray(globalShims) ? globalShims : []).filter(({ moduleName }) => isPkgAvailable(moduleName));
  sharedBufferView !== null && sharedBufferView !== void 0 ? sharedBufferView : sharedBufferView = new Int32Array(sharedBuffer !== null && sharedBuffer !== void 0 ? sharedBuffer : sharedBuffer = new SharedArrayBuffer(INT32_BYTES), 0, 1);
  const useGlobals = finalGlobalShims.length > 0;
  const useEval = isTs ? !tsUseEsm : !jsUseEsm && useGlobals;
  const worker = new Worker(jsUseEsm && useGlobals || tsUseEsm && finalTsRunner === TsRunner.TsNode ? dataUrl(`${generateGlobals(finalWorkerPath, finalGlobalShims)};import '${String(workerPathUrl)}'`) : useEval ? `${generateGlobals(finalWorkerPath, finalGlobalShims, "require")};${encodeImportModule(finalWorkerPath, "require")}` : workerPathUrl, {
    eval: useEval,
    workerData: { sharedBuffer, workerPort, pnpLoaderPath },
    transferList: [workerPort, ...transferList],
    execArgv: finalExecArgv
  });
  let nextID = 0;
  const receiveMessageWithId = (port, expectedId, waitingTimeout) => {
    const start = Date.now();
    const status = Atomics.wait(sharedBufferView, 0, 0, waitingTimeout);
    Atomics.store(sharedBufferView, 0, 0);
    if (!["ok", "not-equal"].includes(status)) {
      const abortMsg = {
        id: expectedId,
        cmd: "abort"
      };
      port.postMessage(abortMsg);
      throw new Error("Internal error: Atomics.wait() failed: " + status);
    }
    const _a = receiveMessageOnPort(mainPort).message, { id } = _a, message = __rest(_a, ["id"]);
    if (id < expectedId) {
      const waitingTime = Date.now() - start;
      return receiveMessageWithId(port, expectedId, waitingTimeout ? waitingTimeout - waitingTime : void 0);
    }
    if (expectedId !== id) {
      throw new Error(`Internal error: Expected id ${expectedId} but got id ${id}`);
    }
    return Object.assign({ id }, message);
  };
  const syncFn = (...args) => {
    const id = nextID++;
    const msg = { id, args };
    worker.postMessage(msg);
    const { result, error, properties } = receiveMessageWithId(mainPort, id, timeout);
    if (error) {
      throw Object.assign(error, properties);
    }
    return result;
  };
  worker.unref();
  return syncFn;
}
function runAsWorker(fn) {
  if (!workerData) {
    return;
  }
  const { workerPort, sharedBuffer: sharedBuffer2, pnpLoaderPath } = workerData;
  if (pnpLoaderPath && IS_NODE_20) {
    module.register(pnpLoaderPath);
  }
  const sharedBufferView2 = new Int32Array(sharedBuffer2, 0, 1);
  parentPort.on("message", ({ id, args }) => {
    ;
    (() => __awaiter(this, void 0, void 0, function* () {
      let isAborted = false;
      const handleAbortMessage = (msg2) => {
        if (msg2.id === id && msg2.cmd === "abort") {
          isAborted = true;
        }
      };
      workerPort.on("message", handleAbortMessage);
      let msg;
      try {
        msg = { id, result: yield fn(...args) };
      } catch (error) {
        msg = { id, error, properties: extractProperties(error) };
      }
      workerPort.off("message", handleAbortMessage);
      if (isAborted) {
        return;
      }
      workerPort.postMessage(msg);
      Atomics.add(sharedBufferView2, 0, 1);
      Atomics.notify(sharedBufferView2, 0);
    }))();
  });
}

export {
  createSyncFn,
  runAsWorker
};
